// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Memo {
    #[prost(message, optional, tag = "1")]
    pub user_swap: ::core::option::Option<memo::UserSwap>,
    /// string because the minimum receive may be very high due to decimal points
    #[prost(string, tag = "2")]
    pub minimum_receive: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub timeout_timestamp: u64,
    #[prost(message, optional, tag = "4")]
    pub post_swap_action: ::core::option::Option<memo::PostAction>,
    #[prost(string, tag = "5")]
    pub recovery_addr: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Memo`.
pub mod memo {
    /// we dont need swap amount since it will be sent via cw20 or native, and we
    /// use that
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SwapExactAssetIn {
        #[prost(message, repeated, tag = "1")]
        pub operations: ::prost::alloc::vec::Vec<SwapOperation>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SmartSwapExactAssetIn {
        #[prost(message, repeated, tag = "1")]
        pub routes: ::prost::alloc::vec::Vec<Route>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Route {
        #[prost(string, tag = "1")]
        pub offer_amount: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub operations: ::prost::alloc::vec::Vec<SwapOperation>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SwapOperation {
        #[prost(string, tag = "1")]
        pub pool_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub denom_in: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub denom_out: ::prost::alloc::string::String,
    }
    /// if none is provided -> error, if more than one attributes are provided ->
    /// error
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserSwap {
        /// or adapter name so that the smart router can redirect to the right swap
        /// router.
        #[prost(string, tag = "1")]
        pub swap_venue_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub swap_exact_asset_in: ::core::option::Option<SwapExactAssetIn>,
        #[prost(message, optional, tag = "3")]
        pub smart_swap_exact_asset_in: ::core::option::Option<SmartSwapExactAssetIn>,
    }
    /// Can possibly have both? -> if both then always contract_call first then ibc
    /// transfer
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostAction {
        #[prost(message, optional, tag = "1")]
        pub ibc_transfer_msg: ::core::option::Option<IbcTransfer>,
        #[prost(message, optional, tag = "2")]
        pub ibc_wasm_transfer_msg: ::core::option::Option<IbcWasmTransfer>,
        #[prost(message, optional, tag = "3")]
        pub contract_call: ::core::option::Option<ContractCall>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IbcTransfer {
        #[prost(string, tag = "1")]
        pub source_channel: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub source_port: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub receiver: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub memo: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub recover_address: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IbcWasmTransfer {
        /// / the local ibc endpoint you want to send tokens back on
        #[prost(string, tag = "1")]
        pub local_channel_id: ::prost::alloc::string::String,
        /// can be 0x or bech32
        #[prost(string, tag = "2")]
        pub remote_address: ::prost::alloc::string::String,
        /// / remote denom so that we know what denom to filter when we query based on
        /// / the asset info. Most likely be: oraib0x... or eth0x...
        #[prost(string, tag = "3")]
        pub remote_denom: ::prost::alloc::string::String,
        /// / How long the packet lives in seconds. If not specified, use
        /// / default_timeout
        #[prost(uint64, optional, tag = "4")]
        pub timeout: ::core::option::Option<u64>,
        /// / metadata of the transfer to suit the new fungible token transfer
        #[prost(string, optional, tag = "5")]
        pub memo: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContractCall {
        #[prost(string, tag = "1")]
        pub contract_address: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub msg: ::prost::alloc::string::String,
    }
}
// @@protoc_insertion_point(module)
